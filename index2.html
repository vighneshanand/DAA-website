<h1 class="h1">Hashing</h1>
<p>Hashing is the transformation of a string of character into a usually shorter fixed-length value or key that represents the original string.</p>
<p>Hashing is used to index and retrieve items in a database because it is faster to find the item using the shortest hashed key than to find it using the original value. It is also used in many encryption algorithms.</p>
<p>A hash code is generated by using a key, which is a unique value.</p>
<p>Hashing is a technique in which given key field value is converted into the address of storage location of the record by applying the same operation on it.</p>
<p>The advantage of hashing is that allows the execution time of basic operation to remain constant even for the larger side.</p>
<h2 class="h2">Why we need Hashing?</h2>
<p>Suppose we have 50 employees, and we have to give 4 digit key to each employee (as for security), and we want after entering a key, direct user map to a particular position where data is stored.</p>
<p>If we give the location number according to 4 digits, we will have to reserve 0000 to 9999 addresses because anybody can use anyone as a key. There is a lot of wastage.</p>
<p>In order to solve this problem, we use hashing which will produce a smaller value of the index of the hash table corresponding to the key of the user.</p>
<h2 class="h2">Universal Hashing</h2>
<p>Let H be a finite collection of hash functions that map a given universe U of keys into the range {0, 1..... m-1}. Such a collection is said to be universal if for each pair of distinct keys k,l&isin;U, the number of hash functions h&isin; H for which h(k)= h(l) is at most |H|/m. In other words, with a hash function randomly chosen from H, the chance of a collision between distinct keys k and l is no more than the chance 1/m of a collision if h(k) and h(l)were randomly and independently chosen from the set {0,1,...m-1}.</p>
<h2 class="h2">Rehashing</h2>
<p>If any stage the hash table becomes nearly full, the running time for the operations of will start taking too much time, insert operation may fail in such situation, the best possible solution is as follows:</p>
<ol class="points">
<li>Create a new hash table double in size.</li>
<li>Scan the original hash table, compute new hash value and insert into the new hash table.</li>
<li>Free the memory occupied by the original hash table.</li>
</ol>
<p><strong>Example:</strong>&nbsp;Consider inserting the keys 10, 22, 31,4,15,28,17,88 and 59 into a hash table of length m = 11 using open addressing with the primary hash function h' (k) = k mod m .Illustrate the result of inserting these keys using linear probing, using quadratic probing with c<sub>1</sub>=1 and c<sub>2</sub>=3, and using double hashing with h<sub>2</sub>(k) = 1 + (k mod (m-1)).</p>
<p><strong>Solution:</strong>&nbsp;Using Linear Probing the final state of hash table would be:</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/rehashing-solution.png" alt="DAA Hashing" /></p>
<p>Using Quadratic Probing with c<sub>1</sub>=1, c<sub>2</sub>=3, the final state of hash table would be h (k, i) = (h' (k) +c<sub>1</sub>*i+ c<sub>2</sub>&nbsp;*i<sup>2</sup>) mod m where m=11 and h' (k) = k mod m.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/rehashing-solution2.png" alt="DAA Hashing" /></p>
<p>Using Double Hashing, the final state of the hash table would be:</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/rehashing-solution3.png" alt="DAA Hashing" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 class="h1">Hash Tables</h1>
<p>It is a collection of items which are stored in such a way as to make it easy to find them later.</p>
<p>Each position in the hash table is called slot, can hold an item and is named by an integer value starting at 0.</p>
<p>The mapping between an item and a slot where the item belongs in a hash table is called a Hash Function. A hash Function accepts a key and returns its hash coding, or hash value.</p>
<p>Assume we have a set of integers 54, 26, 93, 17, 77, 31. Our first hash function required to be as "remainder method" simply takes the item and divide it by table size, returning remainder as its hash value i.e.</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">&nbsp;</div>
<ol class="dp-j" start="1">
<li class="alt">&nbsp;&nbsp;&nbsp;h&nbsp;item&nbsp;=&nbsp;item&nbsp;%&nbsp;(size&nbsp;of&nbsp;table)&nbsp;&nbsp;&nbsp;</li>
<li class="">Let&nbsp;us&nbsp;say&nbsp;the&nbsp;size&nbsp;of&nbsp;table&nbsp;=&nbsp;<span class="number">11</span>,&nbsp;then&nbsp;&nbsp;</li>
<li class="alt"><span class="number">54</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">10</span>&nbsp;&nbsp;&nbsp;<span class="number">26</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">4</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="number">93</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">5</span>&nbsp;&nbsp;</li>
<li class=""><span class="number">17</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">6</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="number">77</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">0</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="number">31</span>&nbsp;%&nbsp;<span class="number">11</span>&nbsp;=&nbsp;<span class="number">9</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>&nbsp;</p>
<table class="alt">
<tbody>
<tr>
<th>ITEM</th>
<th>HASH VALUE</th>
</tr>
<tr>
<td>54</td>
<td>10</td>
</tr>
<tr>
<td>26</td>
<td>4</td>
</tr>
<tr>
<td>93</td>
<td>5</td>
</tr>
<tr>
<td>17</td>
<td>6</td>
</tr>
<tr>
<td>77</td>
<td>0</td>
</tr>
<tr>
<td>31</td>
<td>9</td>
</tr>
</tbody>
</table>
<p><br /><img src="https://static.javatpoint.com/tutorial/daa/images/daa-hash-table.png" alt="DAA Hash Tables" /></p>
<p>Now when we need to search any element, we just need to divide it by the table size, and we get the hash value. So we get the O (1) search time.</p>
<p>Now taking one more element 44 when we apply the hash function on 44, we get (44 % 11 = 0), But 0 hash value already has an element 77. This Problem is called as Collision.</p>
<p><strong>Collision:</strong>&nbsp;According to the Hash Function, two or more item would need in the same slot. This is said to be called as Collision.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/daa-hash-table-collision.png" alt="DAA Hash Tables" /></p>
<p><strong>Figure:</strong>&nbsp;using a hash function h to map keys to hash-table slots. Because keys K2 and k5 map to the same slot, they collide.</p>
<h2 class="h2">Why use HashTable?</h2>
<ol class="points">
<li>If&nbsp;<strong>U</strong>&nbsp;(Universe of keys) is large, storing a table T of size [U] may be impossible.</li>
<li>Set&nbsp;<strong>k</strong>&nbsp;of keys may be small relative to&nbsp;<strong>U</strong>&nbsp;so space allocated for&nbsp;<strong>T</strong>&nbsp;will waste.</li>
</ol>
<p>So Hash Table requires less storage. Indirect addressing element with key k is stored in slot k with hashing it is stored in h (k) where h is a hash f<sup>n</sup>&nbsp;and hash (k) is the value of key k. Hash f<sup>n</sup>&nbsp;required array range.</p>
<h2 class="h2">Application of Hash Tables:</h2>
<p>Some application of Hash Tables are:</p>
<ol class="points">
<li><strong>Database System:</strong>&nbsp;Specifically, those that are required efficient random access. Usually, database systems try to develop between two types of access methods: sequential and random. Hash Table is an integral part of efficient random access because they provide a way to locate data in a constant amount of time.</li>
<li><strong>Symbol Tables:</strong>&nbsp;The tables utilized by compilers to maintain data about symbols from a program. Compilers access information about symbols frequently. Therefore, it is essential that symbol tables be implemented very efficiently.</li>
<li><strong>Data Dictionaries:</strong>&nbsp;Data Structure that supports adding, deleting, and searching for data. Although the operation of hash tables and a data dictionary are similar, other Data Structures may be used to implement data dictionaries.</li>
<li><strong>Associative Arrays:</strong>&nbsp;Associative Arrays consist of data arranged so that n<sup>th</sup>&nbsp;elements of one array correspond to the n<sup>th</sup>&nbsp;element of another. Associative Arrays are helpful for indexing a logical grouping of data by several key fields.</li>
</ol>
<header class="entry-header"></header>
<div class="algo"><header class="entry-header">
<h1 class="entry-title">Sorting Terminology</h1>
</header>
<div class="entry-content">
<p><strong>What is in-place sorting?</strong><br />An in-place sorting algorithm uses constant extra space for producing the output (modifies the given array only). It sorts the list only by modifying the order of the elements within the list.<br />For example, Insertion Sort and Selection Sorts are in-place sorting algorithms as they do not use any additional space for sorting the list and a typical implementation of Merge Sort is not in-place, also the implementation for counting sort is not in-place sorting algorithm.</p>
<p><strong>What are Internal and External Sortings?</strong><br />When all data that needs to be sorted cannot be placed in-memory at a time, the sorting is called&nbsp;<a href="http://en.wikipedia.org/wiki/External_sorting" target="_blank" rel="noopener">external sorting</a>. External Sorting is used for massive amount of data. Merge Sort and its variations are typically used for external sorting. Some external storage like hard-disk, CD, etc is used for external storage.<br />When all data is placed in-memory, then sorting is called internal sorting.</p>
<p><strong>What is stable sorting?</strong><br />See&nbsp;<a href="https://www.geeksforgeeks.org/stability-in-sorting-algorithms/">Stable Sorting Algorithms</a></p>
<p>&nbsp;</p>
<h1 class="h1">Introduction of Backtracking</h1>
<p>The Backtracking is an algorithmic-method to solve a problem with an additional way. It uses a recursive approach to explain the problems. We can say that the backtracking is needed to find all possible combination to solve an optimization problem.</p>
<p><strong>Backtracking</strong>&nbsp;is a systematic way of trying out different sequences of decisions until we find one that "works."</p>
<p>In the following figure</p>
<p>Each non-leaf node in a tree is a parent of one or more other nodes (its children)</p>
<ul class="points">
<li>Each node in the tree, other than the root, has exactly one parent</li>
</ul>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/backtracking-introduction.png" alt="Backtracking Introduction" /></p>
<p>Generally, however, we draw our trees downward, with the root at the top.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/backtracking-introduction2.png" alt="Backtracking Introduction" /></p>
<p>A tree is composed of nodes.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/backtracking-introduction3.png" alt="Backtracking Introduction" /></p>
<p><strong>Backtracking can understand of as searching a tree for a particular "goal" leaf node.</strong></p>
<p>Backtracking is undoubtedly quite simple - we "explore" each node, as follows:</p>
<div class="codeblock">
<pre><strong>To "explore" node N:</strong> 1. If N is a goal node, return "success" 2. If N is a leaf node, return "failure" 3. For each child C of N,     Explore C     If C was successful, return "success" 4. Return "failure"</pre>
</div>
<p>Backtracking algorithm determines the solution by systematically searching the solution space for the given problem. Backtracking is a&nbsp;<strong>depth-first search</strong>&nbsp;with any bounding function. All solution using backtracking is needed to satisfy a complex set of constraints. The constraints may be explicit or implicit.</p>
<p><strong>Explicit Constraint</strong>&nbsp;is ruled, which restrict each vector element to be chosen from the given set.</p>
<p><strong>Implicit Constraint</strong>&nbsp;is ruled, which determine which each of the tuples in the solution space, actually satisfy the criterion function. Figure:</p>
<p>&nbsp;&nbsp;</p>
<h1 class="h1">Recursive Maze Algorithm</h1>
<p>Recursive Maze Algorithm is one of the best examples for backtracking algorithms. Recursive Maze Algorithm is one of the possible solutions for solving the maze.</p>
<h2 class="h2">Maze</h2>
<p>The maze is an area surrounded by walls; in between, we have a path from starting point to ending position. We have to start from the starting point and travel towards from ending point.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/recursive-maze-algorithm.png" alt="Recursive Maze Algorithm" /></p>
<h2 class="h2">Principle of Maze</h2>
<p>As explained above, in the maze we have to travel from starting point to ending point. The problem is to choose the path. If we find any dead-end before ending point, we have to backtrack and move the direction. The direction for traversing is North, East, West, and South. We have to continue "move and backtrack" until we reach the final point.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Consider that we are having a two-dimensional maze cell [WIDTH] [HEIGHT]. Here cell [x] [y] = 1 denotes wall and cell [x] [y] = 0 denotes free cell in the particular location x, y in the maze. The directions we can change in the array are North, East, West, and South. The first step is to make the boundary of the two - dimensional array as one so that we won't go out of the maze and usually reside inside the maze at any time.</p>
<table class="alt">
<tbody>
<tr>
<th colspan="7">Example Maze</th>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Now start changing from the starting position (since the boundary is filled by 1) and find the next free cell then turn to the next free cell and so on. If we grasp a dead-end, we have to backtrack and make the cells in the path as 1 (wall). Continue the same process till the final point is reached.</p>
</div>
</div>